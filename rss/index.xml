<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>B Scherm</title>
    <link>https://elderbas.github.io/blog</link>
    <description>Following along with my travels of coding</description>
    <atom:link href="nlp-parsing-words/feed.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>NLP Parsing Names in JavaScript</title>
        <description><![CDATA[<p>I&#39;m currently working on a project that helps you parse e-books into datasets ready for analytic consumption. After working on my prototype version of <a href="https://gotrends.herokuapp.com">Game of Trends</a> which is a tool for analyzing word frequency trends for words out of the Game of Thrones book series, I thought it&#39;d be more fun to have a tool that you can search not only how often a specific word happens, but <em>who</em> says it.</p>
<p>That opened up even more ideas to being able to do sentiment analysis using APIs such as <a href="https://developer.ibm.com/watson/">IBM&#39;s Watson</a> and do entire expression searches per person.</p>
<p>I realized I either needed to write a script that could fancily infer which character is speaking by context of the sentence arrangement, or I could read the book and and line by line cut and paste the text into:</p>
<pre><code class="language-text">    Billy: &#39;Do you think you can win?&#39;
    Narration: Billy said.
    Joe: &#39;Of course I can.&#39;
</code></pre>
<p>Writing a script with that kind of logic seemed above me so I opted for outsourcing the job to a wonderful contractor on <a href="https://www.freelancer.com/">Freelancer</a> who worked really hard on it. However, I imagine the task wasn&#39;t very fun, despite him saying he&#39;d love to do it, and I ended up with the first book of Game of Thrones parsed similarly to the format just above, but it was riddled with errors and when I&#39;d double check his work many times I found errors.</p>
<p>My first draft tool of this wasn&#39;t too bad. A quick prototype using mostly <a href="https://jquery.com/">jQuery</a> resulted in a tool that you could click on the quoted text and you could select the name of a character already entered in and it would help build a version of the script up above. However, advice that has been given to me by one of the makers behind <a href="http://beehivestartups.com/blog/ziff-making-everyone-data-scientist/">Ziff</a> suggested to incorporate &quot;smarts&quot; into any apps I make. I opted to help predict what the name would be for a given utterance in the book instead of having to select it manually from a dropdown list.</p>
<p>In order to start extracting names I saw a pattern of names generally being in capitals. If it were a full name it was a sequence of capitalized words. I decided to creating some unit tests for a function I thought could parse out sentences that were outside of spoken text.</p>
<pre><code class="language-javascript">&#39;use strict&#39;;
let expect = require(&#39;chai&#39;).expect;
let extractRunningCapitalWords = require(&#39;../src/extractRunningCapitalWords.js&#39;);

describe(&#39;extractRunningCapitalWords&#39;, () =&gt; {
  it(&#39;exists as a function&#39;, function () {
    expect(typeof extractRunningCapitalWords).to.equal(&#39;function&#39;);
  });

  it(&#39;extracts a single word cap&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob&#39;)).to.deep.equal([&#39;Bob&#39;]);
  });

  it(&#39;extracts multiple separate cap word expressions&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob walked, but he saw Jane.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob, do not see Jane.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob. Jane is not here.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob, Jane is not here.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
  });

  it(&#39;extracts a multi word name as one&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob Jones, he saw a cat.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones saw a cat.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
  });

  it(&#39;isnt fooled by common pronouns&#39;, function () {

    expect(extractRunningCapitalWords(&#39;Bob Jones. He is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob and Jane. They are cool.&#39;)).to.deep.equal([&#39;Bob&#39;,&#39;Jane&#39;]);
  });

  it(&#39;less common punctuation marks break in running name&#39;, () =&gt; {
    expect(extractRunningCapitalWords(&#39;Bob Jones - He is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob and Jane: They are cool.&#39;)).to.deep.equal([&#39;Bob&#39;,&#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones: he is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones; They are cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
  });

});//end describe(&#39;bookStorageFormat&#39;
</code></pre>
<p>After passing the tests with</p>
<pre><code class="language-javascript">&#39;use strict&#39;;
let _ = require(&#39;lodash&#39;);

/*
* purpose - to get names out of sentences
*         - if a name is used as &quot;Bob&#39;s&quot;, then it will be used as &quot;Bob&quot;
* */
function extractRunningCapitalWords(sentence) {
  let runningCapWords = [];
  if (_.isUndefined(sentence) || sentence.length &amp;&amp; sentence.trim() === 0) { return runningCapWords; }
  // replace double white spaces with one
  let wordList = sentence.split(&#39; &#39;);
  let startIndexOfRunningWord = null, endIndexOfRunningWord = null;
  _.forEach(wordList, (word, i, arr) =&gt; {
    // word in question is capitalized
    let currWordIsCap = /[A-Z]/.test(word.charAt(0));
    // as long as we keep getting cap words in a row, keep setting the endIndex to the lastest
    if (currWordIsCap) {
      if (_.isNull(startIndexOfRunningWord)){
        startIndexOfRunningWord = endIndexOfRunningWord = i;
      }
      else {
        endIndexOfRunningWord = i;
      }
      // if the current range has any clause-ending punctuation, then name is done being formed
      if (/[,\.:;]/.test(arr[endIndexOfRunningWord])){
        runningCapWords.push(makeDirtyFullNameClean(arr.slice(startIndexOfRunningWord, endIndexOfRunningWord+1).join(&#39; &#39;)));
        startIndexOfRunningWord = endIndexOfRunningWord = null;
      }
    }
    else {
      if (!_.isNull(startIndexOfRunningWord)) {
        let wordToAddOn = arr.slice(startIndexOfRunningWord, endIndexOfRunningWord+1);
        runningCapWords.push(makeDirtyFullNameClean(wordToAddOn.join(&#39; &#39;)));
        startIndexOfRunningWord = endIndexOfRunningWord = null;
      }
    }
    // if we don&#39;t have a cap word, AND startIndex is NOT null, push that index range onto runningCapWords
  });

  if (!_.isNull(startIndexOfRunningWord) &amp;&amp; !_.isNull(endIndexOfRunningWord)){
    let currentWordInRange = wordList.slice(startIndexOfRunningWord, endIndexOfRunningWord+1);
    runningCapWords.push(makeDirtyFullNameClean(currentWordInRange.join(&#39; &#39;)));
  }
  return filterCommonPronouns(runningCapWords);

  function makeDirtyFullNameClean(str) {
    if (/â€™s\b/.test(str)) {
      console.log(&#39;yayy&#39;);
    }
    return str;
    return str.replace(/[^A-z\s-]/g, &#39;&#39;).trim();
  }
  function filterCommonPronouns (arr) {
    let pronouns = [&#39;i&#39;, &#39;he&#39;, &#39;she&#39;, &#39;it&#39;, &#39;we&#39;, &#39;they&#39;];
    return arr.filter((word) =&gt; {
      return !pronouns.includes(word.toLowerCase());
    });
  }
}

module.exports = extractRunningCapitalWords;
</code></pre>
<p>This worked great for the tests but when I started applying the function to my real data I started seeing mostly pieces of text that would hit true for running capital words like <code>Have I...</code> and tons of others that didn&#39;t occur to me at the time. I was thinking I&#39;d have to start creating a hash of instances to ignore when I came across a library called <a href="https://github.com/nlp-compromise/nlp_compromise">nlp_compromise</a> on GitHub. I noticed a feature where you could so something like:</p>
<pre><code class="language-javascript">let nlp = require(&#39;nlp_compromise&#39;);
let listOfPeople = nlp.text(`Brian. Don&#39;t eat too much Captain Crunch.`).people();
console.log(&#39;listOfPeople&#39;, listOfPeople);
</code></pre>
<p>Which worked out great for simple names. I tested out some names I found in Game of Thrones and none of them hit as &#39;People&#39; and sometimes not even nouns. Eventually I came across a section in the documentation where you can add your own words and assign it a specific Tag type (Person, Verb, Noun, or a custom named type like &#39;CherryOnTop&#39;). This was perfect. I realized I could scan sentences around a given piece of speech text and use names already provided by the user and create Person tags for them by simply doing this before calling nlp.text() on anything</p>
<pre><code class="language-javascript">let newLexicon = {};
let namesAddedByUser = [&#39;Splittly Doop&#39;, &#39;Crazy Named Person&#39;];
namesAddByUser.forEach((name) =&gt; {
  newLexicon[name] = &#39;PersonSelected&#39;;
});
nlp.lexicon(newLexicon);

// do other nlp.text() stuff now
</code></pre>
<p>Users would then be identified and tagged as <code>PersonSelected</code> tag type. I didn&#39;t want to just opt for <code>Person</code> which is the default type it assigns names it&#39;s identified, so I could distinguish more easily characters entered by the user. There&#39;s a lot more you can do with the JS library <a href="https://github.com/nlp-compromise/nlp_compromise">nlp_compromise</a>, but it&#39;s the main thing I&#39;m using it for so far in my quest to create an e-book parsing tool.</p>
]]></description>
        <pubDate>Thu Jul 28 2016 21:01:37 GMT-0500 (CDT)</pubDate>
        <link>https://elderbas.github.io/blognlp-parsing-words</link>
        <guid isPermaLink="true">https://elderbas.github.io/blognlp-parsing-words</guid>
      </item>
    
  </channel>
</rss>