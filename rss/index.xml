<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bScherm JavaScript Journey</title>
    <link>/</link>
    <description>Just a static blog.</description>
    <atom:link href="welcome-to-harp/feed.xml" rel="self" type="application/rss+xml" />
    
    
      <item>
        <title>NLP Parsing Names in JavaScript</title>
        <description><![CDATA[<p>I&#39;m currently working on a project that helps you parse e-books into datasets ready for analytic consumption. After working on my prototype version of <a href="https://gotrends.herokuapp.com">Game of Trends</a> which is a tool for analyzing word frequency trends for words out of the Game of Thrones book series, I thought it&#39;d be more fun to have a tool that you can search not only how often a specific word happens, but <em>who</em> says it.</p>
<p>That opened up even more ideas to being able to do sentiment analysis using APIs such as <a href="https://developer.ibm.com/watson/">IBM&#39;s Watson</a> and do entire expression searches per person.</p>
<p>I realized I either needed to write a script that could fancily infer which character is speaking by context of the sentence arrangement, or I could read the book and and line by line cut and paste the text into:</p>
<pre><code class="language-text">    Billy: &#39;Do you think you can win?&#39;
    Narration: Billy said.
    Joe: &#39;Of course I can.&#39;
</code></pre>
<p>Writing a script with that kind of logic seemed above me so I opted for outsourcing the job to a wonderful contractor on <a href="https://www.freelancer.com/">Freelancer</a> who worked really hard on it. However, I imagine the task wasn&#39;t very fun, despite him saying he&#39;d love to do it, and I ended up with the first book of Game of Thrones parsed similarly to the format just above, but it was riddled with errors and when I&#39;d double check his work many times I found errors.</p>
<p>My first draft tool of this wasn&#39;t too bad. A quick prototype using mostly <a href="https://jquery.com/">jQuery</a> resulted in a tool that you could click on the quoted text and you could select the name of a character already entered in and it would help build a version of the script up above. However, advice that has been given to me by one of the makers behind <a href="http://beehivestartups.com/blog/ziff-making-everyone-data-scientist/">Ziff</a> suggested to incorporate &quot;smarts&quot; into any apps I make. I opted to help predict what the name would be for a given utterance in the book instead of having to select it manually from a dropdown list.</p>
<p>In order to start extracting names I saw a pattern of names generally being in capitals. If it were a full name it was a sequence of capitalized words. I decided to creating some unit tests for a function I thought could parse out sentences that were outside of spoken text.</p>
<pre><code class="language-javascript">&#39;use strict&#39;;
let expect = require(&#39;chai&#39;).expect;
let extractRunningCapitalWords = require(&#39;../src/extractRunningCapitalWords.js&#39;);

describe(&#39;extractRunningCapitalWords&#39;, () =&gt; {
  it(&#39;exists as a function&#39;, function () {
    expect(typeof extractRunningCapitalWords).to.equal(&#39;function&#39;);
  });

  it(&#39;extracts a single word cap&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob&#39;)).to.deep.equal([&#39;Bob&#39;]);
  });

  it(&#39;extracts multiple separate cap word expressions&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob walked, but he saw Jane.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob, do not see Jane.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob. Jane is not here.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob, Jane is not here.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
  });

  it(&#39;extracts a multi word name as one&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob Jones, he saw a cat.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones saw a cat.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
  });

  it(&#39;isnt fooled by common pronouns&#39;, function () {

    expect(extractRunningCapitalWords(&#39;Bob Jones. He is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob and Jane. They are cool.&#39;)).to.deep.equal([&#39;Bob&#39;,&#39;Jane&#39;]);
  });

  it(&#39;less common punctuation marks break in running name&#39;, () =&gt; {
    expect(extractRunningCapitalWords(&#39;Bob Jones - He is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob and Jane: They are cool.&#39;)).to.deep.equal([&#39;Bob&#39;,&#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones: he is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones; They are cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
  });

});//end describe(&#39;bookStorageFormat&#39;
</code></pre>
<p>After passing the tests with</p>
<pre><code class="language-javascript">&#39;use strict&#39;;
let _ = require(&#39;lodash&#39;);

/*
* purpose - to get names out of sentences
*         - if a name is used as &quot;Bob&#39;s&quot;, then it will be used as &quot;Bob&quot;
* */
function extractRunningCapitalWords(sentence) {
  let runningCapWords = [];
  if (_.isUndefined(sentence) || sentence.length &amp;&amp; sentence.trim() === 0) { return runningCapWords; }
  // replace double white spaces with one
  let wordList = sentence.split(&#39; &#39;);
  let startIndexOfRunningWord = null, endIndexOfRunningWord = null;
  _.forEach(wordList, (word, i, arr) =&gt; {
    // word in question is capitalized
    let currWordIsCap = /[A-Z]/.test(word.charAt(0));
    // as long as we keep getting cap words in a row, keep setting the endIndex to the lastest
    if (currWordIsCap) {
      if (_.isNull(startIndexOfRunningWord)){
        startIndexOfRunningWord = endIndexOfRunningWord = i;
      }
      else {
        endIndexOfRunningWord = i;
      }
      // if the current range has any clause-ending punctuation, then name is done being formed
      if (/[,\.:;]/.test(arr[endIndexOfRunningWord])){
        runningCapWords.push(makeDirtyFullNameClean(arr.slice(startIndexOfRunningWord, endIndexOfRunningWord+1).join(&#39; &#39;)));
        startIndexOfRunningWord = endIndexOfRunningWord = null;
      }
    }
    else {
      if (!_.isNull(startIndexOfRunningWord)) {
        let wordToAddOn = arr.slice(startIndexOfRunningWord, endIndexOfRunningWord+1);
        runningCapWords.push(makeDirtyFullNameClean(wordToAddOn.join(&#39; &#39;)));
        startIndexOfRunningWord = endIndexOfRunningWord = null;
      }
    }
    // if we don&#39;t have a cap word, AND startIndex is NOT null, push that index range onto runningCapWords
  });

  if (!_.isNull(startIndexOfRunningWord) &amp;&amp; !_.isNull(endIndexOfRunningWord)){
    let currentWordInRange = wordList.slice(startIndexOfRunningWord, endIndexOfRunningWord+1);
    runningCapWords.push(makeDirtyFullNameClean(currentWordInRange.join(&#39; &#39;)));
  }
  return filterCommonPronouns(runningCapWords);

  function makeDirtyFullNameClean(str) {
    if (/â€™s\b/.test(str)) {
      console.log(&#39;yayy&#39;);
    }
    return str;
    return str.replace(/[^A-z\s-]/g, &#39;&#39;).trim();
  }
  function filterCommonPronouns (arr) {
    let pronouns = [&#39;i&#39;, &#39;he&#39;, &#39;she&#39;, &#39;it&#39;, &#39;we&#39;, &#39;they&#39;];
    return arr.filter((word) =&gt; {
      return !pronouns.includes(word.toLowerCase());
    });
  }
}

module.exports = extractRunningCapitalWords;
</code></pre>
<p>This worked great for the tests but when I started applying the function to my real data I started seeing mostly pieces of text that would hit true for running capital words like <code>Have I...</code> and tons of others that didn&#39;t occur to me at the time. I was thinking I&#39;d have to start creating a hash of instances to ignore when I came across a library called <a href="https://github.com/nlp-compromise/nlp_compromise">nlp_compromise</a> on GitHub. I noticed a feature where you could so something like:</p>
<pre><code class="language-javascript">let nlp = require(&#39;nlp_compromise&#39;);
let listOfPeople = nlp.text(`Brian. Don&#39;t eat too much Captain Crunch.`).people();
console.log(&#39;listOfPeople&#39;, listOfPeople);
</code></pre>
<p>Which worked out great for simple names. I tested out some names I found in Game of Thrones and none of them hit as &#39;People&#39; and they weren&#39;t flagged as people and sometimes not even nouns. Eventually I came across a section in the documentation where you can add your own words and assign it a specific Tag type (Person, Verb, Noun, or a custom named type like &#39;CherryOnTop&#39;). This was perfect. I realized I could scan sentences around a given piece of speech text and use names already provided by the user and create Person tags for them by simply doing this before calling nlp.text() on anything</p>
<pre><code class="language-javascript">let newLexicon = {};
let namesAddedByUser = [&#39;Splittly Doop&#39;, &#39;Crazy Named Person&#39;];
namesAddByUser.forEach((name) =&gt; {
  newLexicon[name] = &#39;PersonSelected&#39;;
});
nlp.lexicon(newLexicon);

// do other nlp.text() stuff now
</code></pre>
<p>Users would then be identified and tagged as <code>PersonSelected</code> tag type. I didn&#39;t want to just opt for <code>Person</code> which is the default type it assigns names it&#39;s identified, so I could distinguish more easily characters entered by the user. There&#39;s a lot more you can do with the JS library <a href="https://github.com/nlp-compromise/nlp_compromise">nlp_compromise</a>, but it&#39;s the main thing I&#39;m using it for so far in my quest to create an e-book parsing tool.</p>
]]></description>
        <pubDate>Thu Jul 28 2016 20:13:02 GMT-0500 (CDT)</pubDate>
        <link>/nlp-parsing-words</link>
        <guid isPermaLink="true">/nlp-parsing-words</guid>
      </item>
    
    
      <item>
        <title>Welcome to Harp</title>
        <description><![CDATA[<p>This little posts will introduce you to Markdown in Harp. Go ahead and edit the <code>welcome-to-harp.md</code> file to get going and learn how it all works!</p>
<h2>Getting Started</h2><p>Writing in Markdown is really easy. Where appropriate, you can use <em>formatting</em> shortcuts to style your content. For example, a list:</p>
<ul>
<li>Item number one</li>
<li>Item number two<ul>
<li>A nested item</li>
</ul>
</li>
<li>A final item</li>
</ul>
<p>or with numbers!</p>
<ol>
<li>Remember to buy some milk</li>
<li>Drink the milk</li>
<li>Tweet that I remembered to buy the milk, and drank it</li>
</ol>
<h3>Links</h3><p>Want to link to a source? No problem. If you paste in url, like <a href="http://harpjs.com">http://harpjs.com</a> - itâ€™ll automatically be linked up. But if you want to customise your anchor text, you can do that too! Hereâ€™s a link to <a href="http://harpjs.com">the Harp website</a>. Neat.</p>
<h3>What about Images?</h3><p>Images work too! Already know the URL of the image you want to include in your article? Simply paste it in like this to make it show up:</p>
<p><img src="http://harpjs.com/identity/resources/750/harp-wordmark-white-on-blue.png" alt="The Harp Logo"></p>
<p>Not sure which image you want to use yet? Thatâ€™s ok too. Leave yourself a descriptive placeholder and keep writing.</p>
<p>![A bowl of bananas]</p>
<h3>Quoting</h3><p>Sometimes a link isnâ€™t enough, you want to quote someone on what theyâ€™ve said. It was probably very wisdomous. Is wisdomous a word? Find out in a future release when we introduce spellcheck! For now â€“ itâ€™s definitely a word.</p>
<blockquote>
<p>Wisdomous â€“ itâ€™s definitely a word.</p>
</blockquote>
<h3>Working with Code</h3><p>Got a streak of geek? Weâ€™ve got you covered there, too. You can write inline <code>&lt;code&gt;</code> blocks really easily with back ticks. Want to show off something more comprehensive? Using <code>```</code> at the beginning and end of the block gets you there.</p>
<pre><code class="language-css">.awesome-thing {
    display: block;
    width: 100%;
}
</code></pre>
<h3>Ready for a Break?</h3><p>Throw 3 or more dashes down on any new line and youâ€™ve got yourself a fancy new divider. Aw yeah.</p>
<hr>
<h3>Advanced Usage</h3><p>Thereâ€™s one fantastic secret about Markdown. If you want, you can write plain old HTML and it&#39;ll still work! Very flexible.</p>
<input type="text" placeholder="Iâ€™m an input field!" />

<p>That should be enough to get you started with Markdown.</p>
<h2>Learn more about Harp</h2><p>Now, youâ€™re probably read to start customising your static blog with Harp. Take a look at these helpful resources:</p>
<ul>
<li><a href="http://harpjs.com/docs/quick-start">Harp quick start guide</a></li>
<li><a href="http://kennethormandy.com/journal/start-a-blog-with-harp">Start a blog with Harp blog post</a></li>
<li><a href="http://harpjs.com/docs/">The Harp documentation</a></li>
</ul>
]]></description>
        <pubDate>Thu Jul 28 2016 20:13:02 GMT-0500 (CDT)</pubDate>
        <link>/welcome-to-harp</link>
        <guid isPermaLink="true">/welcome-to-harp</guid>
      </item>
    
  </channel>
</rss>