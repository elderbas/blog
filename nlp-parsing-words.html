<!DOCTYPE html>
<html>
<head>
    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Page Meta -->
    <title>NLP Parsing Names in JavaScript</title>
    <meta name="description" content="Following along with my travels of coding" />

    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><!-- K: Need assets variable , or something like basepath -->

    <!-- <link rel="shortcut icon" href="favicon.ico">-->

    <!-- Styles'n'Scripts -->
    
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Noto+Serif:400,700,400italic|Open+Sans:700,400" />
    <link rel="stylesheet" type="text/css" href="/blog/assets/css/screen.css" />
    <link rel="stylesheet" type="text/css" href="/blog/assets/prism/themes/prism-okaidia.css" />
    <script type="text/javascript" src="/blog/assets/js/jquery.fitvids.js"></script>


    <!-- Ghost outputs important style and meta data with this tag -->
    <!-- {{ghost_head}} -->
</head>
<body class="post-template"><!-- K: body_class variable, home page class is home-template, post is like: post-template tag-getting-started -->

    <!-- Everything else gets inserted here -->
    
        <main class="content" role="main">

    <article class="post"><!-- K: {{post_class}}, tags- -->
        <!-- Each post has the blog logo at the top, with a link back to the home page -->
        <!-- Each post has the blog logo at the top, with a link back to the home page -->
<header class="post-header">
    <a class="blog-logo" href="https://elderbas.github.io/blog">
        
            <span class="blog-title">B Scherm</span>
        
    </a>
</header>

        <!-- Everything below outputs content of the the post which has been published -->
        <span class="post-meta"><time datetime="Thu, 28 Jul 2016 05:00:00 GMT">28 Jul 2016</time> on NLP,JavaScript,Data Science<!-- {{tags prefix="on " separator=" | "}} --></span>

        <h1 class="post-title">NLP Parsing Names in JavaScript</h1>

        <section class="post-content">
            <p>I&#39;m currently working on a project that helps you parse e-books into datasets ready for analytic consumption. After working on my prototype version of <a href="https://gotrends.herokuapp.com">Game of Trends</a> which is a tool for analyzing word frequency trends for words out of the Game of Thrones book series, I thought it&#39;d be more fun to have a tool that you can search not only how often a specific word happens, but <em>who</em> says it.</p>
<p>That opened up even more ideas to being able to do sentiment analysis using APIs such as <a href="https://developer.ibm.com/watson/">IBM&#39;s Watson</a> and do entire expression searches per person.</p>
<p>I realized I either needed to write a script that could fancily infer which character is speaking by context of the sentence arrangement, or I could read the book and and line by line cut and paste the text into:</p>
<pre><code class="language-text">    Billy: &#39;Do you think you can win?&#39;
    Narration: Billy said.
    Joe: &#39;Of course I can.&#39;
</code></pre>
<p>Writing a script with that kind of logic seemed above me so I opted for outsourcing the job to a wonderful contractor on <a href="https://www.freelancer.com/">Freelancer</a> who worked really hard on it. However, I imagine the task wasn&#39;t very fun, despite him saying he&#39;d love to do it, and I ended up with the first book of Game of Thrones parsed similarly to the format just above, but it was riddled with errors and when I&#39;d double check his work many times I found errors.</p>
<p>My first draft tool of this wasn&#39;t too bad. A quick prototype using mostly <a href="https://jquery.com/">jQuery</a> resulted in a tool that you could click on the quoted text and you could select the name of a character already entered in and it would help build a version of the script up above. However, advice that has been given to me by one of the makers behind <a href="http://beehivestartups.com/blog/ziff-making-everyone-data-scientist/">Ziff</a> suggested to incorporate &quot;smarts&quot; into any apps I make. I opted to help predict what the name would be for a given utterance in the book instead of having to select it manually from a dropdown list.</p>
<p>In order to start extracting names I saw a pattern of names generally being in capitals. If it were a full name it was a sequence of capitalized words. I decided to creating some unit tests for a function I thought could parse out sentences that were outside of spoken text.</p>
<pre><code class="language-javascript">&#39;use strict&#39;;
let expect = require(&#39;chai&#39;).expect;
let extractRunningCapitalWords = require(&#39;../src/extractRunningCapitalWords.js&#39;);

describe(&#39;extractRunningCapitalWords&#39;, () =&gt; {
  it(&#39;exists as a function&#39;, function () {
    expect(typeof extractRunningCapitalWords).to.equal(&#39;function&#39;);
  });

  it(&#39;extracts a single word cap&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob&#39;)).to.deep.equal([&#39;Bob&#39;]);
  });

  it(&#39;extracts multiple separate cap word expressions&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob walked, but he saw Jane.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob, do not see Jane.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob. Jane is not here.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob, Jane is not here.&#39;)).to.deep.equal([&#39;Bob&#39;, &#39;Jane&#39;]);
  });

  it(&#39;extracts a multi word name as one&#39;, function () {
    expect(extractRunningCapitalWords(&#39;Bob Jones, he saw a cat.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones saw a cat.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
  });

  it(&#39;isnt fooled by common pronouns&#39;, function () {

    expect(extractRunningCapitalWords(&#39;Bob Jones. He is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob and Jane. They are cool.&#39;)).to.deep.equal([&#39;Bob&#39;,&#39;Jane&#39;]);
  });

  it(&#39;less common punctuation marks break in running name&#39;, () =&gt; {
    expect(extractRunningCapitalWords(&#39;Bob Jones - He is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob and Jane: They are cool.&#39;)).to.deep.equal([&#39;Bob&#39;,&#39;Jane&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones: he is cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
    expect(extractRunningCapitalWords(&#39;Bob Jones; They are cool.&#39;)).to.deep.equal([&#39;Bob Jones&#39;]);
  });

});//end describe(&#39;bookStorageFormat&#39;
</code></pre>
<p>After passing the tests with</p>
<pre><code class="language-javascript">&#39;use strict&#39;;
let _ = require(&#39;lodash&#39;);

/*
* purpose - to get names out of sentences
*         - if a name is used as &quot;Bob&#39;s&quot;, then it will be used as &quot;Bob&quot;
* */
function extractRunningCapitalWords(sentence) {
  let runningCapWords = [];
  if (_.isUndefined(sentence) || sentence.length &amp;&amp; sentence.trim() === 0) { return runningCapWords; }
  // replace double white spaces with one
  let wordList = sentence.split(&#39; &#39;);
  let startIndexOfRunningWord = null, endIndexOfRunningWord = null;
  _.forEach(wordList, (word, i, arr) =&gt; {
    // word in question is capitalized
    let currWordIsCap = /[A-Z]/.test(word.charAt(0));
    // as long as we keep getting cap words in a row, keep setting the endIndex to the lastest
    if (currWordIsCap) {
      if (_.isNull(startIndexOfRunningWord)){
        startIndexOfRunningWord = endIndexOfRunningWord = i;
      }
      else {
        endIndexOfRunningWord = i;
      }
      // if the current range has any clause-ending punctuation, then name is done being formed
      if (/[,\.:;]/.test(arr[endIndexOfRunningWord])){
        runningCapWords.push(makeDirtyFullNameClean(arr.slice(startIndexOfRunningWord, endIndexOfRunningWord+1).join(&#39; &#39;)));
        startIndexOfRunningWord = endIndexOfRunningWord = null;
      }
    }
    else {
      if (!_.isNull(startIndexOfRunningWord)) {
        let wordToAddOn = arr.slice(startIndexOfRunningWord, endIndexOfRunningWord+1);
        runningCapWords.push(makeDirtyFullNameClean(wordToAddOn.join(&#39; &#39;)));
        startIndexOfRunningWord = endIndexOfRunningWord = null;
      }
    }
    // if we don&#39;t have a cap word, AND startIndex is NOT null, push that index range onto runningCapWords
  });

  if (!_.isNull(startIndexOfRunningWord) &amp;&amp; !_.isNull(endIndexOfRunningWord)){
    let currentWordInRange = wordList.slice(startIndexOfRunningWord, endIndexOfRunningWord+1);
    runningCapWords.push(makeDirtyFullNameClean(currentWordInRange.join(&#39; &#39;)));
  }
  return filterCommonPronouns(runningCapWords);

  function makeDirtyFullNameClean(str) {
    if (/â€™s\b/.test(str)) {
      console.log(&#39;yayy&#39;);
    }
    return str;
    return str.replace(/[^A-z\s-]/g, &#39;&#39;).trim();
  }
  function filterCommonPronouns (arr) {
    let pronouns = [&#39;i&#39;, &#39;he&#39;, &#39;she&#39;, &#39;it&#39;, &#39;we&#39;, &#39;they&#39;];
    return arr.filter((word) =&gt; {
      return !pronouns.includes(word.toLowerCase());
    });
  }
}

module.exports = extractRunningCapitalWords;
</code></pre>
<p>This worked great for the tests but when I started applying the function to my real data I started seeing mostly pieces of text that would hit true for running capital words like <code>Have I...</code> and tons of others that didn&#39;t occur to me at the time. I was thinking I&#39;d have to start creating a hash of instances to ignore when I came across a library called <a href="https://github.com/nlp-compromise/nlp_compromise">nlp_compromise</a> on GitHub. I noticed a feature where you could so something like:</p>
<pre><code class="language-javascript">let nlp = require(&#39;nlp_compromise&#39;);
let listOfPeople = nlp.text(`Brian. Don&#39;t eat too much Captain Crunch.`).people();
console.log(&#39;listOfPeople&#39;, listOfPeople);
</code></pre>
<p>Which worked out great for simple names. I tested out some names I found in Game of Thrones and none of them hit as &#39;People&#39; and sometimes not even nouns. Eventually I came across a section in the documentation where you can add your own words and assign it a specific Tag type (Person, Verb, Noun, or a custom named type like &#39;CherryOnTop&#39;). This was perfect. I realized I could scan sentences around a given piece of speech text and use names already provided by the user and create Person tags for them by simply doing this before calling nlp.text() on anything</p>
<pre><code class="language-javascript">let newLexicon = {};
let namesAddedByUser = [&#39;Splittly Doop&#39;, &#39;Crazy Named Person&#39;];
namesAddByUser.forEach((name) =&gt; {
  newLexicon[name] = &#39;PersonSelected&#39;;
});
nlp.lexicon(newLexicon);

// do other nlp.text() stuff now
</code></pre>
<p>Users would then be identified and tagged as <code>PersonSelected</code> tag type. I didn&#39;t want to just opt for <code>Person</code> which is the default type it assigns names it&#39;s identified, so I could distinguish more easily characters entered by the user. There&#39;s a lot more you can do with the JS library <a href="https://github.com/nlp-compromise/nlp_compromise">nlp_compromise</a>, but it&#39;s the main thing I&#39;m using it for so far in my quest to create an e-book parsing tool.</p>
        </section>

        <footer class="post-footer">

            
                <section class="author">
                    <h4>Brian Schermerhorn</h4>
                    <p>github.com/elderbas - </p>
                </section>
            

            <section class="share">
                <h4>Share this post</h4>
                <a class="icon-twitter" href="http://twitter.com/share?text=NLP Parsing Names in JavaScript&url=https://elderbas.github.io/blognlp-parsing-words"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <span class="hidden">Twitter</span>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://elderbas.github.io/blognlp-parsing-words"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <span class="hidden">Facebook</span>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=https://elderbas.github.io/blognlp-parsing-words"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <span class="hidden">Google+</span>
                </a>
            </section>

        </footer>

    </article>

</main>
    

    <footer class="site-footer">
    <a class="subscribe icon-feed" href="/rss/index.xml"><span class="tooltip">Subscribe!</span></a>
    <div class="inner">
         <section class="copyright">All content copyright <a href="/">B Scherm</a> &copy; 2016 &bull; All rights reserved.</section>
         <section class="poweredby">Proudly published with <a class="" href="http://harpjs.com">Harp</a></section>
    </div>
</footer>

    <!-- Ghost outputs important scripts and data with this tag -->
    <!-- {{ghost_foot}} -->

    <!-- The main JavaScript file for Casper -->

    
    <script type="text/javascript" src="/blog/assets/js/index.js"></script>
    <script type="text/javascript" src="/blog/assets/prism/prism.js"></script>
    <script type="text/javascript" src="/blog/assets/prism/components/prism-javascript.min.js"></script>

</body>
</html>